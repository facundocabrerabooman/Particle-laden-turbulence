function [freq,iHes,Puis]=MVA13mult1(sig,sigeps2,flag_init)% [freq,iHes,Puis]=MVA13mult1(sig,flag_init);%% programme MVA de recherche d'une source dans un signal complexe% il y a au plus une source plus du bruit qui peut etre plus ou moins organise% on ajoute donc au plus une source pour en tenir compte% on regarde la valeur de l'amplitude pour arreter le decodage%% ©2000 nmordant %%%%%%%%%%%%%%% PARAMETRES %%%%%%%%%%%%%%%NbVoies=1;NbMic=7;							% nombre de "micros" ( taille de la fenetre )K=13;								% nombre de moyennesNbSmax=2;						% nombre maximum de sourcesMaxIter=100;  					% nb max d'iterationsepsilon=1e-8; 					% test de convergence de la premiere estimation%sigeps2=2e-8;					% sigma^2 de modelisationnfft=64;							% fenetre de fft pour la premiere valeur%seuil_ihessian=0.1^2;		% niveau du test pour le choix des sources%seuil_ihessian=0.04^2;%seuil_ihessian=0.05^2;seuil_ihessian=1e10;deltaf=0.1;						% distance minimale entre deux sourcesfen=100;							% demi-largeur de la fenetre de lissage du iHessienseuil_puis_stop=1.5e-5^2;         % valeur du seuil de la puissance pour arreter l'algolong_max=400;					% longueur max sur laquelle le Hessien est autorise a depasser le seuil %%%%%%%%%%%%%%%%%%%% INITIALISATIONS %%%%%%%%%%%%%%%%%%%%if (odd(NbMic+K-1)-NbMic-K+1)>0				% il faut une taille de fenetre (NbMic+K-1) impaire    NbMic=NbMic+1;end;dec=(NbMic+K)/2;time=1;Lsig=length(sig);tot=Lsig-K-NbMic+2;freq=zeros(NbSmax,Lsig);Puis=zeros(NbSmax,Lsig);%sigma2=zeros(1,Lsig);trG=zeros(1,Lsig);vp=zeros(NbMic,Lsig);iHes=zeros(NbSmax,Lsig);Puis_test=zeros(1,Lsig);ind_Puis=zeros(1,Lsig);long=0;NbStab=ones(1,Lsig);p=fix(tot/10);ff=linspace(-0.5,0.5-1/nfft,nfft);fenetre=hanning(nfft).';for i=2:NbVoies    fenetre=[fenetre;hanning(nfft).'];end;%%%%%%%%%%%%%%%%%%%%%%%% PREMIERE ESTIMATION %%%%%%%%%%%%%%%%%%%%%%%%%disp(['NbMic=',int2str(NbMic)]);%disp(['K=',int2str(K)]);%disp(['NbSmax=',int2str(NbSmax)]);%disp(['sigeps2=',num2str(sigeps2)]);if (flag_init==1)        %initialisations        NbS=1; 											% on part avec une seule source        % recherche d'une premiere valeur : max de la fft        if length(sig)<nfft        sig=[sig,zeros(NbVoies,nfft-length(sig))];    end;        %tf=fftshift(mean(abs(fft((sig(:,1:nfft).*fenetre).')')));    tf=fftshift(abs(fft((sig(:,1:nfft).*fenetre).')'));    [m,id]=max(tf);    Teta=2*pi*ff(id);        % estimation de la matrice de covariance    Rx=zeros(NbMic,NbMic);    for vv=1:NbVoies        Rx=Rx+matcor(sig(vv,1:K+NbMic-1),NbMic);    end;    Rx=Rx/NbVoies;        %Decomposition en elts propres, calcul de PiB et Ry.           [U,VP,V]=svd(Rx);    VP=diag(VP);    vp(:,dec)=VP;        PiB=zeros(NbMic,NbMic);    syg2=0;    for k=(NbS+1):NbMic;        PiB=PiB+U(:,k)*U(:,k)';        syg2=syg2+VP(k);    end;    syg2=abs(syg2/(NbMic-NbS));		% valeur estimee du bruit    Ry=zeros(NbMic,NbMic);    for k=1:NbS;        Ry=Ry+(VP(k)-syg2)*U(:,k)*U(:,k)';    end;             Nb_Iter=0;    Veps=10;    while ((Nb_Iter<MaxIter)&((Veps'*Veps)>epsilon^2));     % test de convergence        Nb_Iter=Nb_Iter+1;																						        Tetac=Teta;                                      Sc=zeros(NbMic,NbS);        for k=1:NbS;            Sc(:,k)=exp(1i*Tetac(k)*(0:(NbMic-1))');%/sqrt(NbMic);        end;                                             DSc=diag(1i*(1:NbMic))*Sc;          iSSt=inv(Sc'*Sc);        PiBc=eye(NbMic)-Sc*iSSt*Sc';        P=iSSt*Sc'*Ry*Sc*iSSt;        Grad=(2*K/syg2)*real(diag(DSc'*PiBc*PiB*Sc*P));        Hessian=(2*K/syg2)*real((DSc'*PiBc*PiB*PiBc*DSc).*conj(P));        iHess=inv(Hessian);        Veps=iHess*Grad;                                Teta=Tetac-Veps';    end;    iHes(1:NbS,dec)=diag(iHess);    freq(1:NbS,dec)=mod(Teta.'/2/pi+0.5,1)-0.5;        % test et ajout eventuel d'une source         if iHes(1,dec)>seuil_ihessian					% on ajoute une source ( on suppose qu'il y en a au moins une )        NbS=2;        q=find(diff(sign(diff(tf)))==-2)+1;			% recherche des max de la tf        [m,I]=sort(-tf(q));								% tri dans l'ordre croissant        k=2;        while abs(ff(q(I(1)))-ff(q(I(2))))<deltaf	% test de la proximite des max            k=k+1;            I(2)=I(k);        end;        Teta=2*pi*ff(q(I(1:NbS)));                PiB=zeros(NbMic,NbMic);        syg2=0;        for k=(NbS+1):NbMic;            PiB=PiB+U(:,k)*U(:,k)';            syg2=syg2+VP(k);        end;        syg2=abs(syg2/(NbMic-NbS));		% valeur estimee du bruit        Ry=zeros(NbMic,NbMic);        for k=1:NbS;            Ry=Ry+(VP(k)-syg2)*U(:,k)*U(:,k)';        end;                 Nb_Iter=0;        Veps=10;        while ((Nb_Iter<MaxIter)&((Veps'*Veps)>epsilon^2));     % test de convergence            Nb_Iter=Nb_Iter+1;																						            Tetac=Teta;                                          Sc=zeros(NbMic,NbS);            for k=1:NbS;                Sc(:,k)=exp(1i*Tetac(k)*(0:(NbMic-1))');%/sqrt(NbMic);            end;                                                 DSc=diag(1i*(1:NbMic))*Sc;              iSSt=inv(Sc'*Sc);            PiBc=eye(NbMic)-Sc*iSSt*Sc';            P=iSSt*Sc'*Ry*Sc*iSSt;            Grad=(2*K/syg2)*real(diag(DSc'*PiBc*PiB*Sc*P));            Hessian=(2*K/syg2)*real((DSc'*PiBc*PiB*PiBc*DSc).*conj(P));            iHess=inv(Hessian);            %Veps=iHess*Grad;                                    Teta=Tetac-Veps';        end;        iHes(1:NbS,dec)=diag(iHess);        freq(1:NbS,dec)=mod(Teta.'/2/pi+0.5,1)-0.5;    end;    NbStab(dec)=NbS;        else    NbS=NbS_0;    Teta=Teta_0;    freq(1:NbS,dec)=Teta_0.'/2/pi;    iHes(1:NbS,dec)=diag(iHes_0);    iHess=iHes_0;end;%%%%%%%%%%%%%%%%%%%%%%%%%% ESTIMATIONS SUIVANTES %%%%%%%%%%%%%%%%%%%%%%%%%%Reps=sigeps2.*eye(NbS);%Hess0=Hessian;Gamma=iHess;for ii=(dec+1):tot+dec-1    %if rem(ii,p)==0 disp([int2str(round(ii/tot*100)),' %']);end;        % Acquisition d'une nouvelle matrice Rx    Rx=zeros(NbMic,NbMic);    for vv=1:NbVoies        Rx=Rx+matcor(sig(vv,ii-dec+1:ii-dec+K+NbMic-1),NbMic);    end;    Rx=Rx/NbVoies;        %Decomposition en elts propres, calcul de PiB et Ry.           [U,VP,V]=svd(Rx);    VP=diag(VP);    vp(:,ii)=VP;        PiB=zeros(NbMic,NbMic);    syg2=0;    for k=(NbS+1):NbMic;        PiB=PiB+U(:,k)*U(:,k)';        syg2=syg2+VP(k);    end;    syg2=abs(syg2/(NbMic-NbS));		% valeur estimee du bruit    Ry=zeros(NbMic,NbMic);    for k=1:NbS;        Ry=Ry+(VP(k)-syg2)*U(:,k)*U(:,k)';    end;         % premier passage sans changer le nombre de sources           Tetac=Teta;                                  Sc=zeros(NbMic,NbS);    for k=1:NbS        Sc(:,k)=exp(1i*Tetac(k)*(0:(NbMic-1))');%/sqrt(NbMic);    end;                                         DSc=diag(1i*(-(NbMic-1)/2:1:(NbMic-1)/2))*Sc;      iSSt=inv(Sc'*Sc);    PiBc=eye(NbMic)-Sc*iSSt*Sc';    P=iSSt*Sc'*Ry*Sc*iSSt;    Grad=(2*K/syg2)*real(diag(DSc'*PiBc*PiB*Sc*P));    Hessian=(2*K/syg2)*real((DSc'*PiBc*PiB*PiBc*DSc).*conj(P));    iHess=inv(Hessian);    iHes(1:NbS,ii)=diag(iHess);    %Veps=iHess*Grad;        %mise a jour du hessien    Gammac=Gamma+Reps;    Hess0=inv(Gammac)+Hessian;    iHess=inv(Hess0);    Gamma=iHess;        %nouvelle estimee de teta    Teta=Tetac-(iHess*Grad)';    freq(1:NbS,ii)=mod(Teta.'/2/pi+0.5,1)-0.5;        % test de validite du modele        if (NbS==1)        if (iHes(1,ii)>seuil_ihessian)	% soit on a deux sources, soit on en a aucune...            NbS=2;            Reps=sigeps2.*eye(NbS);            %Reps=[sigeps2,0;0,8*sigeps2];            Gamma=Gamma*eye(NbS);            % on recommence avec deux sources il faut donc initialiser la seconde..pb de position de la fenetre de fft?            if ii-nfft/2+1>0                if ii+nfft/2>Lsig                    s=[sig(:,ii-nfft/2+1:Lsig),zeros(NbVoies,ii+nfft/2-Lsig)];                else                    s=sig(:,ii-nfft/2+1:ii+nfft/2);                end;            else                 n=nfft/2-ii;                s=[zeros(NbVoies,n),sig(:,1:ii+nfft/2)];            end;                     %tf=abs(fftshift(fft(s.*hanning(nfft),nfft)));            tf=fftshift(mean(abs(fft((s.*fenetre).')')));            hold off;plot(ff,tf);grid;pause;            q=find(diff(sign(diff(tf)))==-2)+1            [m,I]=sort(-tf(q));            k=2;            while abs(ff(q(I(1)))-ff(q(I(2))))<deltaf&(k<length(I))                k=k+1;                I(2)=I(k);            end;            if abs(ff(q(I(1)))-ff(q(I(2))))<deltaf                Tetac=[2*pi*ff(q(I(1))),pi];            else                Tetac=2*pi*ff(q(I(1:NbS)));            end;            [m,I]=min([abs(Teta(1)-Tetac(1)),abs(Teta(1)-Tetac(2))]);            if I==2                Tetac=Tetac(2:-1:1);            end;            Tetac(1)=Teta(1);                                    PiB=zeros(NbMic,NbMic);            syg2=0;            for k=(NbS+1):NbMic;                PiB=PiB+U(:,k)*U(:,k)';                syg2=syg2+VP(k);            end;            syg2=abs(syg2/(NbMic-NbS));		% valeur estimee du bruit            Ry=zeros(NbMic,NbMic);            for k=1:NbS;                Ry=Ry+(VP(k)-syg2)*U(:,k)*U(:,k)';            end;             Sc=zeros(NbMic,NbS);            for k=1:NbS                Sc(:,k)=exp(1i*Tetac(k)*(0:(NbMic-1))');%/sqrt(NbMic);            end;                                                 DSc=diag(1i*(-(NbMic-1)/2:1:(NbMic-1)/2))*Sc;              iSSt=inv(Sc'*Sc);            PiBc=eye(NbMic)-Sc*iSSt*Sc';            P=iSSt*Sc'*Ry*Sc*iSSt;            Grad=(2*K/syg2)*real(diag(DSc'*PiBc*PiB*Sc*P));            Hessian=(2*K/syg2)*real((DSc'*PiBc*PiB*PiBc*DSc).*conj(P));            iHess=inv(Hessian);            iHes(1:NbS,ii)=diag(iHess);            %Veps=iHess*Grad;            Gammac=Gamma+Reps;            Hess0=inv(Gammac)+Hessian;            iHess=inv(Hess0);            Gamma=iHess;            Teta=Tetac-(iHess*Grad)';            freq(1:NbS,ii)=mod(Teta.'/2/pi+0.5,1)-0.5;            trG(ii)=trace(Gamma);        end;    else        if ((iHes(2,ii)>4*seuil_ihessian)&(iHes(1,ii)<seuil_ihessian))|abs(diff(freq(:,ii)))<deltaf                                  % seule situation claire : la 2e source disparait		            NbS=1;            Reps=sigeps2.*eye(NbS);            % on recommence avec une seule source...            Tetac=Teta(1);               Gamma=Gamma(1,1);                        PiB=zeros(NbMic,NbMic);            syg2=0;            for k=(NbS+1):NbMic;                PiB=PiB+U(:,k)*U(:,k)';                syg2=syg2+VP(k);            end;            syg2=abs(syg2/(NbMic-NbS));		% valeur estimee du bruit            Ry=zeros(NbMic,NbMic);            for k=1:NbS;                Ry=Ry+(VP(k)-syg2)*U(:,k)*U(:,k)';            end;                         Sc=zeros(NbMic,NbS);            for k=1:NbS                Sc(:,k)=exp(1i*Tetac(k)*(0:(NbMic-1))');%/sqrt(NbMic);            end;                                                 DSc=diag(1i*(-(NbMic-1)/2:1:(NbMic-1)/2))*Sc;              iSSt=inv(Sc'*Sc);            PiBc=eye(NbMic)-Sc*iSSt*Sc';            P=iSSt*Sc'*Ry*Sc*iSSt;            Grad=(2*K/syg2)*real(diag(DSc'*PiBc*PiB*Sc*P));            Hessian=(2*K/syg2)*real((DSc'*PiBc*PiB*PiBc*DSc).*conj(P));            iHess=inv(Hessian);            iHes(1,ii)=diag(iHess);            iHes(2,ii)=0;            %Veps=iHess*Grad;            Gammac=Gamma+Reps;            Hess0=inv(Gammac)+Hessian;            iHess=inv(Hess0);            Gamma=iHess;            Teta=Tetac-(iHess*Grad)';            freq(1:NbS,ii)=mod(Teta.'/2/pi+0.5,1)-0.5;            trG(ii)=trace(Gamma);        end;    end;                NbStab(ii)=NbS;    %freq(1:NbS,ii)=Teta.'/2/pi;    freq(1:NbS,ii)=mod(Teta.'/2/pi+0.5,1)-0.5;    trG(ii)=trace(Gamma);    Puis(1:NbS,ii)=abs(diag(P));    %Puis(1:NbS,ii)=diag(iSSt*Sc'*(eye(size(PiBc))-PiBc)*Rx*(eye(size(PiBc))-PiBc)*Sc*iSSt);                % test pour la fin eventuelle du decodage       if ii>2*fen        Puis_test(ii-fen)=mean(Puis(1,ii-2*fen:ii));        if Puis_test(ii-fen)<seuil_puis_stop             ind_Puis(ii-fen)=1;        end;        if ind_Puis(ii-fen)==1            if ind_Puis(ii-fen-1)==1	% le precedent est aussi au dessus du seuil                long=long+1;                if long>long_max				% on a depasse la longueur max autorisee                    disp('fin du segment')                    freq=freq(:,1:ii-fen);                    iHes=iHes(:,1:ii-fen);                    Puis=Puis(:,1:ii-fen);                    clear DSc PiBc ff p Gamma flag_init q Gammac Reps s Grad Rx i seuil_ihessian Hess0 Ry seuil_puis_stop Hessian                    clear Sc Puis_test I Teta iHess sigeps2 K Tetac iSSt Lsig U id MaxIter V ii syg2 NbMic VP tf NBSmax k time tot                    clear dec lond NbVoies deltaf long_max vp Nb_Iter epsilon m vv P fen PiB fenetre nfft NbS NbSmax Veps                    clear ind_iHes long                                        return;                end;            else								% le precedent est sous le seuil                long=1;            end;        end;    end;        end;clear DSc PiBc ff p Gamma flag_init q Gammac Reps s Grad Rx i seuil_ihessian Hess0 Ry seuil_ihessian_stop Hessianclear Sc iHes_test I Teta iHess sigeps2 K Tetac iSSt Lsig U id MaxIter V ii syg2 NbMic VP tf NBSmax k time totclear dec lond deltaf long_max vp Nb_Iter epsilon m vv P fen PiB fenetre nfft NbS NbSmax Vepsclear ind_iHes longclear NbVoies%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%